## 数据结构课程设计

---

[TOC]

### 课程设计题目

### 课程设计目标

1. 使用`C++`实现一个较为通用的矩阵模板
2. 使用这个模板实现一个矩阵求逆的算法
3. 使用`julia`实现算法的仿真与速度测试

### 课程设计算法及实现

* 概述

  **本次进行课程设计的环境**：

  1. 操作系统： `Manjaro Gnome`

     ```
      ██████████████████  ████████     quantumbird@Ptilopsis
      ██████████████████  ████████     OS: Manjaro 18.1.5 Juhraya
      ██████████████████  ████████     Kernel: x86_64 Linux 4.19.91-1-MANJARO
      ██████████████████  ████████     Uptime: 22m
      ████████            ████████     Packages: 1705
      ████████  ████████  ████████     Shell: zsh 5.7.1
      ████████  ████████  ████████     Resolution: 1920x2160
      ████████  ████████  ████████     DE: GNOME 3.34.2
      ████████  ████████  ████████     WM: Mutter
      ████████  ████████  ████████     WM Theme: Matcha-sea
      ████████  ████████  ████████     GTK Theme: Matcha-sea [GTK2/3]
      ████████  ████████  ████████     Icon Theme: Papirus-Dark-Maia
      ████████  ████████  ████████     Font: Noto Sans 11
      ████████  ████████  ████████     Disk: 53G / 62G (91%)
                                       CPU: Intel Core i5-8250U @ 8x 3.4GHz [43.0°C]
                                       GPU: Mesa DRI Intel(R) UHD Graphics 620 (Kabylake GT2) 
                                       RAM: 2167MiB / 7738MiB
     
     ```

  2. 编译器 / 解释器版本及编译选项：

     1. `C++` 编译器：`g++ (GCC)9.2.0` ; 编译选项: `g++ -std=c++11 -O2`
     2. `julia` 解释器：`julia version 1.3.0` 

  3. `IDE` / 编辑器 及其他

     * `IDE` : `VsCode`
     * 编辑器：`Vim`
     * 构建工具：`make`

  **使用的工具简述**

  * `C++` ：

  * `Julia`：

    一种使用`llvm` 作为后端的语言

  **课设内容概述**

  本次课程设计中，我设计了一套`C++` 矩阵运算库的接口，这套矩阵运算库实现了完整的基础线性代数运算，并实现了其主要的接口与基础的朴素矩阵类，且使用这套矩阵运算库实现了矩阵的`LU` 分解算法，经验证，该实现较为可靠，速度较朴素算法有一定的优势。

  在`C++` 实现上，我使用`julia` 对算法速度上进行验证，并与其相同思路的算法在不同问题规模的运行速度了对比验证。在原本朴素`LU`分解的基础上，同时探讨了分块矩阵的`LU`分解算法的时间复杂度部分与实现细节。

* 矩阵模板设计及分析

  1. 矩阵模板的一些期望及要点：

     * 对于不同种类的矩阵，应当有对应的算法去完成其不同操作
     * 在不同类型矩阵之间运算应满足“约束最强”原则
     * 不同类型的矩阵应当有一个统一的`API` 
     * 有一个容器可以封装不同矩阵类型的细节，且可以自动处理矩阵类型之间的转换关系
     * 不同类型的矩阵运算导致的类型变换由模板自动计算

  2. 矩阵模板的`API`

     * 矩阵类的操作：

       1. 建立一个矩阵
       2. 得到矩阵的参数
       3. 通过下标访问矩阵的元素
       4. 得到矩阵的类型

     * 基础矩阵操作函数：[低层 `API`]

       1. `MatCopy` : 拷贝一个矩阵（深拷贝）
       2. `MatElemTypeTrans` : 矩阵元素类型转换
       3. `MatTransp` : 矩阵转置
       4. `MatMultM` : 矩阵相乘
       5. `MatMultC` : 矩阵与元素相乘
       6. `MatPlusM` ： 矩阵相加
       7. `MatPlusC` : 矩阵元素相加
       8. `MatSubtM` : 矩阵相减
       9. `MatSubtC` : 矩阵减去元素
       10. `MatDivC` : 矩阵与元素相除

       对于部分特殊矩阵来说：

       1. `MatToGE` ： 将矩阵转为 GE 类型
       2. `MatFromGE` ： 从 GE 类型构造矩阵

  3. 矩阵模板关键操作的算法及实现分析

     * 朴素矩阵（GE）:

       1. 矩阵相乘：

          对于矩阵相乘，朴素的算法是通过使用三重循环来使矩阵中的元素依次相乘再相加，理所当然的，时间复杂度为$O(n^3)$ ，优点是实现起来十分简单，核心代码甚至不超过四行，但效率着实感人。

          一般的数值线性代数库使用的是类似于`Stress`算法的分块矩阵乘法算法，通过使用分治的思想，将时间复杂度降至$O(n^{2.7})$ 甚至更低，同时分块算法可以方便的实现并行化，更加充分的利用计算资源。

          除了使用一些思想将理论上的时间复杂度降下来以外，在实际编写的时候也有一些 trick 去降低算法实现的常数，例如：

          对于`C/C++`，数组存储是按行存储的，而在`fortran` 中，数组是按列存储的，而访问一个相邻的元素与访问一个距离较远的元素速度是有一定区别的，这导致即使在编写朴素矩阵乘法算法实现时，嵌套循环的循序不同也可能影响算法实现运行的效率。

          在高性能数值线性代数库中，存储矩阵时规模对运算速度也有一些细微但可优化的影响，矩阵的规模在满足一定条件时（例如是2的幂时），在运算时会大大增加 cache 未命中几率，导致触发换页，影响算法效率。

          对于`Stress`算法 ，在进行矩阵分割的时候，子矩阵规模也会影响算法实现的效率，对于不同的硬件，其分割子矩阵的常数的最优值也不尽相同。

       2. 矩阵转置：

          朴素矩阵转置算法时间复杂度为$O(n^2)$ ，在我看来，可优化的地方不如矩阵相乘的多。

     * 压缩存储三角矩阵（TP）：

       1. 矩阵相乘：

          对于压缩存储三角矩阵（以下称为TP）来说，按照上三角矩阵 / 下三角矩阵（L / U），对角线 / 反对角线 （slash / back slash）分为四种，不同类型的TP相乘得到的类型也不尽相同，在使用`C++`实现的时候，通过将这两个分类标准设计为模板参数，使用模板偏特化等技巧，为不同的情况设计不同的算法。

          最糟糕的是，TP之间的矩阵乘法不是一个封闭运算：TP与TP相乘之后的矩阵可能不是TP矩阵，即

          ```haskell
          MatMultM :: (TP A) => A -> A -> A
          ```

          不是恒成立的（从代数的角度来看，就一点也不优雅，简直逼死强迫症。。。），导致需要设计一套通过矩阵类型和操作类型推断当前矩阵类型的类型系统。不幸中的万幸，通过使用`C++` 的模板元编程写一堆在编译器计算的模板函数，可以完成这个工作，并且实际编写`demo` 成功也证明了其可行性。

       2. 矩阵转置：

          转置运算对于TP是封闭的，由于部分矩阵无法或很难完成原址转置，为了`API`的统一，在设计时直接返回一个新的矩阵，对于`C++`实现来说，只要不为矩阵类提供拷贝构造函数，在函数返回时会触发移动语义，因此不必过于担心内存拷贝带来的时间浪费问题。

  4. 矩阵模板的类型系统（设想，待实现）

     1. GE - GEnearl 稠密矩阵	[已完成]
     2. GB - Genearl Band 带状矩阵 
     3. SY - SYmmetric 对称矩阵                > 可看作 GE 的子类
     4. SB - Symmetric Band 对称带状矩阵
     5. SP - Symmetric Packed 压缩存储对称矩阵
     6. HE - HEmmitian Hemmitian矩阵           > 可看作 GE 的子类
     7. HB - Hemmitian Band 带状Hemmitian矩阵
     8. TR - TRiangular 三角矩阵               > 可看作 GE 的子类
     9. TB - Triangular Band 三角带状矩阵   [部分完成，未测试]
     10. TP - Triangular Packed 压缩存储三角矩阵   [部分完成，未测试]

     11. SE - SparsE 稀疏矩阵

     在进行矩阵运算时，类型系统应满足“约束最强”的原则，即在运算开始与结束时，应保证矩阵类型对矩阵的约束是最强的。例如：GE对一个矩阵中的元素排列和值几乎没有什么要求，因此GE是约束最弱的矩阵类型；TR要求矩阵中的元素只占矩阵的一半，且所有元素都在矩阵对角线的一侧，因此TR的约束要强于GE。

* 矩阵求逆算法设计及分析

  1. Gauss 消元法
  2. 伴随矩阵法
  3. `LU`分解
  4. 分块`LU`分解
  5. `SVD`分解算法

* 不同算法在不同规模下运行时间的对比

  

### 在进行课程设计时遇到的问题与解决办法

1. 在设计较高层次`API`时遇到代码重复的问题

   在进行`Mat`这个类时，由于它是底层不同矩阵类的包装，要根据不同类调用不同方法。在设计之初，我借鉴了`Python` 中的“鸭子类型”(duck type)的概念，虽然后面证明这是一个较为正确的选择，但如何简单的实现是一个问题。

   起初我使用`switch`语句完成不同类型的选择工作，但写出来的代码重复性高，极为丑陋。此时`Mat`定义如下。

   ```
   template<typename T, class MType>
   class Mat {...}
   ```

   但使用一些模板的trick，修改底部的矩阵类型的定义，其中加入：

   ```
   typedef const T ElemType;
   ```

   `Mat`的定义即可修改为：

   ```
   template<class MType>
   class Mat
   ```

   此时，在`Mat`中，我们可以直接使用

   ```
   typedef typename MType::ElemType ElemType;
   ```

   将被包装的矩阵的元素类型提取出来。
   合理的利用`C++`强大的元编程能力，将部分类型交给编译器去计算，将少写很多重复的模板代码（说的好，我选择`Python/Scala/Haskell/Lisp` :)）

2. 在设计`TP` （压缩三角矩阵）时遇到问题：三角矩阵相乘不一定是三角矩阵，无法使用多态来完成矩阵相乘类型的优化。

   使用模板函数来完成编译期类型计算：

   | up_triang | slash | up_triang | slash | up_triang | slah | (GE) |
   | --------- | ----- | --------- | ----- | --------- | ---- | ---- |
   | false     | false | false     | false |           |      | true |
   | false     | true  | false     | true  | false     | true |      |
   | true      | false | true      | false |           |      | true |
   | true      | true  | true      | true  | true      | true |      |

### 课程设计总结

### Reference

